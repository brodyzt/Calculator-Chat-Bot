(*all the rsa computation, using the congruence module,
  in addition to prime generation*)


(*[gen_private_key] is a randomly generated private_key with very high
  probability *)
 val gen_private_key: unit -> Eval.value

(*[get_public_key k] is the RSA public key associated with
  private key k*)
val get_public_key: Eval.private_key -> Eval.value

(*[encrypt k s] is the integer generated by encoding string s
  with RSA public key k*)
 val encrypt: Eval.public_key -> string -> Eval.value

(*[decrypt k i] is the string s, where i is the result of
  [encrypt k's] with k' being the public key coresponding to
  private key k*)
 val decrypt: Eval.private_key -> Eval.integer -> Eval.value

(*[crack k i] is the Some s, where i is the result of [encrypt k s]
  this could take a very long time if i can not be factored quickly*)
 val crack: Eval.public_key -> Eval.integer -> Eval.value
