(*all the rsa computation, using the congruence module,
  in addition to prime generation*)
include Eval

(*A public_key of (n,e) is an RSA public key
  where gcd(e,n) = 1 and n = pq for some
  primes p and q*)
type public_key = integer * integer

(*A private_key of (d,p,q) is an RSA private key (d,pq) for
  the public key (e,n), where gcd(d,n) = 1
  and d satisfies e*d = 1 (mod phi(n)), where phi
  is the Euler phi function*)
type private_key = integer * integer * integer

(*[gen_private_key] is a randomly generated private_key with very high
  probability *)
 val gen_private_key: unit -> value

(*[get_public_key k] is the RSA public key associated with
  private key k*)
val get_public_key: private_key -> value

(*[encrypt k s] is the integer generated by encoding string s
  with RSA public key k*)
 val encrypt: public_key -> string -> value

(*[decrypt k i] is the string s, where i is the result of
  [encrypt k's] with k' being the public key coresponding to
  private key k*)
 val decrypt: private_key -> integer -> value

(*[crack k i] is the Some s, where i is the result of [encrypt k s]
  this could take a very long time if i can not be factored quickly*)
 val crack: public_key -> integer -> value
