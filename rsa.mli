(*all the rsa computation, using the congruence module,
  in addition to prime generation*)
open Eval
(*A public_key of (n,e) is an RSA public key
  where gcd(e,n) = 1 and n = pq for some
  primes p and q*)
type public_key = integer * integer

(*A private_key of (e,n,d) is an RSA private key (d,n) for
  the public key (e,n), where gcd(e,n) = 1, n = pq for some
  primes p and q, and d satisfies e*d = 1 (mod phi(n)), where phi
  is the Euler phi function*)
type private_key = integer * integer * integer

(*[gen_private_key] is a randomly generated private_key*)
 val gen_private_key: unit -> private_key

(*[get_public_key k] is the RSA public key associated with
  private key k*)
val get_public_key: private_key -> public_key

(*[encrypt k s] is the integer generated by encoding string s
  with RSA public key k*)
 val encrypt: public_key -> string -> integer

(*[decrypt k i] is the string s, where i is the result of
  [encrypt k's] with k' being the public key corespponding to
  private key k*)
 val decrypt: private_key -> integer -> string

(*[crack k i] is the Some s, where i is the result of [encrypt k s]
  or None if the number i cannot be factored quickly*)
 val crack: public_key -> integer -> string option
